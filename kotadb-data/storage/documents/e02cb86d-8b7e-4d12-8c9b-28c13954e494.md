---
tags:
- file
- kota-db
- ext_ts
---
import { createTestClient, createTestDocument, validateDocumentStructure, MCPTestClient, PerformanceTimer } from './test-helpers';

describe('Real-World MCP Integration Scenarios', () => {
  let client: MCPTestClient;
  let perfTimer: PerformanceTimer;

  beforeAll(async () => {
    client = await createTestClient();
    perfTimer = new PerformanceTimer();
  }, 15000);

  afterAll(async () => {
    await client.cleanup();
  });

  describe('New User Onboarding Flow', () => {
    test('should support complete user onboarding workflow', async () => {
      // Step 1: New user checks available tools
      const tools = await client.listTools();
      expect(tools.length).toBe(7);
      
      // Step 2: User checks database stats (should be empty)
      const initialStats = await client.getStats();
      expect(initialStats.total_documents).toBe(0);
      expect(initialStats.total_size_bytes).toBe(0);
      
      // Step 3: User creates their first document
      const firstDoc = await client.createDocument({
        path: '/welcome.md',
        title: 'Welcome to KotaDB',
        content: 'This is my first document in KotaDB. I can store knowledge here.',
        tags: ['welcome', 'first-document'],
      });
      
      validateDocumentStructure(firstDoc);
      expect(firstDoc.title).toBe('Welcome to KotaDB');
      
      // Step 4: User verifies document was created
      const retrieved = await client.getDocument(firstDoc.id);
      expect(retrieved.id).toBe(firstDoc.id);
      expect(retrieved.content).toBe(firstDoc.content);
      
      // Step 5: User sees updated stats
      const updatedStats = await client.getStats();
      expect(updatedStats.total_documents).toBe(1);
      expect(updatedStats.total_size_bytes).toBeGreaterThan(0);
      
      // Step 6: User lists all documents
      const docList = await client.listDocuments();
      expect(docList.documents.length).toBe(1);
      expect(docList.total).toBe(1);
      expect(docList.documents[0].id).toBe(firstDoc.id);
    });

    test('should handle user creating multiple documents rapidly', async () => {
      const documents = await Promise.all([
        client.createDocument({
          path: '/notes/meeting-1.md',
          title: 'Team Meeting Notes',
          content: 'Discussed project timeline and deliverables',
          tags: ['meeting', 'team'],
        }),
        client.createDocument({
          path: '/ideas/feature-request.md',
          title: 'Feature Request Ideas',
          content: 'Users want better search functionality',
          tags: ['ideas', 'features'],
        }),
        client.createDocument({
          path: '/research/market-analysis.md',
          title: 'Market Analysis Report',
          content: 'Comprehensive analysis of competitor landscape',
          tags: ['research', 'analysis'],
        }),
      ]);

      // All documents should be created successfully
      documents.forEach(doc => {
        validateDocumentStructure(doc);
        expect(doc.id).toBeDefined();
      });

      // Verify all can be retrieved
      const retrievalPromises = documents.map(doc => client.getDocument(doc.id));
      const retrieved = await Promise.all(retrievalPromises);
      
      retrieved.forEach((doc, index) => {
        expect(doc.id).toBe(documents[index].id);
        expect(doc.title).toBe(documents[index].title);
      });
    });
  });

  describe('Knowledge Management Workflow', () => {
    test('should support comprehensive knowledge management scenario', async () => {
      // Create a knowledge base with related documents
      const docs = await Promise.all([
        client.createDocument({
          path: '/kb/rust-basics.md',
          title: 'Rust Programming Basics',
          content: 'Rust is a systems programming language focused on safety and performance. Key concepts include ownership, borrowing, and lifetimes.',
          tags: ['rust', 'programming', 'basics'],
        }),
        client.createDocument({
          path: '/kb/rust-advanced.md',
          title: 'Advanced Rust Concepts',
          content: 'Advanced Rust topics: async programming, macros, unsafe code, and advanced trait usage.',
          tags: ['rust', 'programming', 'advanced'],
        }),
        client.createDocument({
          path: '/kb/javascript-basics.md',
          title: 'JavaScript Fundamentals',
          content: 'JavaScript fundamentals: variables, functions, objects, and asynchronous programming with promises.',
          tags: ['javascript', 'programming', 'basics'],
        }),
      ]);

      // User searches for programming content
      const programmingSearch = await client.searchDocuments('programming');
      expect(programmingSearch.length).toBe(3);
      
      // User searches for specific language
      const rustSearch = await client.searchDocuments('Rust');
      expect(rustSearch.length).toBe(2);
      expect(rustSearch.every(doc => doc.title.includes('Rust'))).toBe(true);
      
      // User updates a document with new information
      const updatedDoc = await client.updateDocument(
        docs[0].id,
        docs[0].content + '\n\nUpdated: Added information about cargo package manager.'
      );
      expect(updatedDoc.content).toContain('cargo package manager');
      expect(updatedDoc.updatedAt).not.toBe(docs[0].updatedAt);
      
      // User searches for the new content
      const cargoSearch = await client.searchDocuments('cargo');
      expect(cargoSearch.length).toBe(1);
      expect(cargoSearch[0].id).toBe(docs[0].id);
      
      // User organizes by listing documents
      const allDocs = await client.listDocuments();
      expect(allDocs.total).toBeGreaterThanOrEqual(3);
      
      // User removes outdated document
      const deleted = await client.deleteDocument(docs[2].id);
      expect(deleted).toBe(true);
      
      // Verify deletion
      const finalList = await client.listDocuments();
      const finalIds = finalList.documents.map((doc: any) => doc.id);
      expect(finalIds).not.toContain(docs[2].id);
    });

    test('should handle complex search scenarios', async () => {
      // Create documents with various content types
      await Promise.all([
        client.createDocument({
          path: '/research/ai-trends-2024.md',
          title: 'AI Trends for 2024',
          content: 'Machine learning and artificial intelligence trends including large language models, computer vision, and neural networks.',
          tags: ['ai', 'research', '2024', 'trends'],
        }),
        client.createDocument({
          path: '/projects/ml-project.md',
          title: 'Machine Learning Project Plan',
          content: 'Project plan for implementing a machine learning solution using Python and TensorFlow.',
          tags: ['ml', 'project', 'python', 'tensorflow'],
        }),
        client.createDocument({
          path: '/notes/conference-ai.md',
          title: 'AI Conference Notes',
          content: 'Key takeaways from AI conference: transformer architecture, attention mechanisms, and neural network optimization.',
          tags: ['conference', 'ai', 'notes', 'neural-networks'],
        }),
      ]);

      // Test various search patterns
      const searches = await Promise.all([
        client.searchDocuments('machine learning'),
        client.searchDocuments('neural networks'),
        client.searchDocuments('AI'),
        client.searchDocuments('python'),
        client.searchDocuments('2024'),
      ]);

      // Verify search results make sense
      expect(searches[0].length).toBeGreaterThan(0); // machine learning
      expect(searches[1].length).toBeGreaterThan(0); // neural networks
      expect(searches[2].length).toBeGreaterThan(0); // AI
      expect(searches[3].length).toBeGreaterThan(0); // python
      expect(searches[4].length).toBeGreaterThan(0); // 2024

      // Test search ranking (more relevant results should rank higher)
      const mlResults = searches[0];
      if (mlResults.length > 1) {
        expect(mlResults[0].score).toBeGreaterThanOrEqual(mlResults[1].score);
      }
    });
  });

  describe('Collaborative Workflow Simulation', () => {
    test('should support multiple concurrent users scenario', async () => {
      // Simulate multiple users working simultaneously
      const userADoc = client.createDocument({
        path: '/team/user-a-notes.md',
        title: 'User A Meeting Notes',
        content: 'Notes from user A about project requirements',
        tags: ['team', 'user-a', 'meeting'],
      });

      const userBDoc = client.createDocument({
        path: '/team/user-b-progress.md',
        title: 'User B Progress Update',
        content: 'Progress update from user B on development tasks',
        tags: ['team', 'user-b', 'progress'],
      });

      const userCDoc = client.createDocument({
        path: '/team/user-c-research.md',
        title: 'User C Research Findings',
        content: 'Research findings from user C on technical solutions',
        tags: ['team', 'user-c', 'research'],
      });

      // Wait for all concurrent operations
      const [docA, docB, docC] = await Promise.all([userADoc, userBDoc, userCDoc]);

      // All users search for team content
      // Search for documents specifically from this test (with unique user tags)
      const teamSearch = await client.searchDocuments('team user');
      expect(teamSearch.length).toBeGreaterThanOrEqual(3);

      // Simulate users updating documents in parallel
      const updatePromises = [
        client.updateDocument(docA.id, docA.content + '\n\nAction items: Follow up with stakeholders'),
        client.updateDocument(docB.id, docB.content + '\n\nCompleted: API integration'),
        client.updateDocument(docC.id, docC.content + '\n\nRecommendation: Use microservices architecture'),
      ];

      const updates = await Promise.all(updatePromises);
      
      // Verify all updates succeeded
      updates.forEach(update => {
        expect(update.content).toContain('\n\n');
        validateDocumentStructure(update);
      });

      // Verify search still works after updates
      const postUpdateSearch = await client.searchDocuments('team user');
      expect(postUpdateSearch.length).toBeGreaterThanOrEqual(3);
    });
  });

  describe('Performance Under Real-World Load', () => {
    test('should maintain performance with growing document collection', async () => {
      // Create a substantial number of documents to test performance
      const numDocs = 50;
      const createPromises = Array.from({ length: numDocs }, (_, i) =>
        client.createDocument({
          path: `/perf-test/doc-${i}.md`,
          title: `Performance Test Document ${i}`,
          content: `This is performance test document number ${i}. ` +
            'It contains various keywords for testing search performance: ' +
            `technology, innovation, development, testing, performance, document-${i}`,
          tags: ['performance', 'test', `doc-${i}`],
        })
      );

      perfTimer.start();
      const docs = await Promise.all(createPromises);
      const createTime = perfTimer.end();

      expect(docs.length).toBe(numDocs);
      console.log(`Created ${numDocs} documents in ${createTime}ms`);

      // Test search performance
      perfTimer.start();
      const searchResults = await client.searchDocuments('performance', 100); // Increase limit to handle all docs
      const searchTime = perfTimer.end();

      expect(searchResults.length).toBeGreaterThanOrEqual(numDocs);
      expect(searchTime).toBeLessThan(1000); // Should be under 1 second
      console.log(`Searched ${numDocs} documents in ${searchTime}ms`);

      // Test listing performance
      perfTimer.start();
      const listResult = await client.listDocuments(100);
      const listTime = perfTimer.end();

      expect(listResult.total).toBeGreaterThanOrEqual(numDocs);
      expect(listTime).toBeLessThan(500); // Should be under 500ms
      console.log(`Listed documents in ${listTime}ms`);

      // Test individual document retrieval performance
      const randomDoc = docs[Math.floor(Math.random() * docs.length)];
      
      perfTimer.start();
      const retrieved = await client.getDocument(randomDoc.id);
      const retrievalTime = perfTimer.end();

      expect(retrieved.id).toBe(randomDoc.id);
      expect(retrievalTime).toBeLessThan(100); // Should be very fast
      console.log(`Retrieved document in ${retrievalTime}ms`);
    });

    test('should handle burst traffic patterns', async () => {
      // Simulate burst of mixed operations
      const burstOperations = [
        // Document creations
        ...Array.from({ length: 10 }, (_, i) =>
          client.createDocument({
            path: `/burst/create-${i}.md`,
            content: `Burst creation test document ${i}`,
          })
        ),
        // Searches
        ...Array.from({ length: 5 }, () =>
          client.searchDocuments('test')
        ),
        // Stats queries
        ...Array.from({ length: 3 }, () =>
          client.getStats()
        ),
        // List operations
        ...Array.from({ length: 2 }, () =>
          client.listDocuments(20)
        ),
      ];

      perfTimer.start();
      const results = await Promise.all(burstOperations);
      const burstTime = perfTimer.end();

      // All operations should succeed
      expect(results.length).toBe(20);
      console.log(`Completed burst of 20 operations in ${burstTime}ms`);

      // Average time per operation should be reasonable
      const avgTimePerOp = burstTime / results.length;
      expect(avgTimePerOp).toBeLessThan(200);
    });
  });

  describe('Data Persistence and Recovery', () => {
    test('should persist data across server restarts', async () => {
      // Create test documents
      const testDocs = await Promise.all([
        client.createDocument({
          path: '/persistence/doc1.md',
          title: 'Persistence Test 1',
          content: 'This document should survive server restarts',
        }),
        client.createDocument({
          path: '/persistence/doc2.md',
          title: 'Persistence Test 2',
          content: 'Another document for persistence testing',
        }),
      ]);

      // Record initial state
      const initialStats = await client.getStats();
      expect(initialStats.total_documents).toBeGreaterThanOrEqual(2);

      // Simulate server restart by creating new client with same data directory
      const tempDir = client.getTempDir();
      await client.cleanup();

      // Create new client with same data directory
      const newClient = await createTestClient();
      // Note: In a real implementation, we'd need to reuse the same temp directory
      // For this test, we verify the concept works with persistence layers

      // Verify new client can work independently
      const newStats = await newClient.getStats();
      expect(typeof newStats.total_documents).toBe('number');
      expect(typeof newStats.total_size_bytes).toBe('number');

      await newClient.cleanup();
      client = await createTestClient(); // Restore original client for other tests
    });

    test('should handle data corruption gracefully', async () => {
      // Create a document to ensure system is working
      const doc = await client.createDocument({
        path: '/corruption-test.md',
        title: 'Corruption Test',
        content: 'Testing graceful handling of issues',
      });

      validateDocumentStructure(doc);

      // The system should continue to work normally
      const searchResult = await client.searchDocuments('corruption');
      expect(searchResult.length).toBeGreaterThan(0);

      const stats = await client.getStats();
      expect(stats.total_documents).toBeGreaterThan(0);
    });
  });

  describe('Error Recovery Scenarios', () => {
    test('should recover from temporary system stress', async () => {
      // Create baseline document
      const baselineDoc = await client.createDocument({
        path: '/stress-test.md',
        content: 'Baseline document for stress testing',
      });

      // Generate system stress with rapid operations
      const stressOperations = [];
      for (let i = 0; i < 20; i++) {
        stressOperations.push(
          client.createDocument({
            path: `/stress/doc-${i}.md`,
            content: `Stress test document ${i}`,
          })
        );
      }

      // Execute stress operations
      const stressResults = await Promise.allSettled(stressOperations);
      
      // Some operations might fail under stress, but server should remain stable
      const successful = stressResults.filter(r => r.status === 'fulfilled');
      const failed = stressResults.filter(r => r.status === 'rejected');
      
      console.log(`Stress test: ${successful.length} succeeded, ${failed.length} failed`);

      // Server should still be responsive after stress
      const recoveryCheck = await client.getDocument(baselineDoc.id);
      expect(recoveryCheck.id).toBe(baselineDoc.id);

      // Should still be able to perform basic operations
      const postStressDoc = await client.createDocument({
        path: '/post-stress.md',
        content: 'Document created after stress test',
      });
      expect(postStressDoc.id).toBeDefined();
    });
  });
});