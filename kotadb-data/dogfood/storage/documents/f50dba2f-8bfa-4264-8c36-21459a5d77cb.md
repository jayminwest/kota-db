---
tags:
- file
- kota-db
- ext_rs
---
//! Factory functions for creating production-ready components
//!
//! This module provides factory functions that return fully-wrapped components
//! with all production features enabled (tracing, validation, retries, caching).

use anyhow::Result;
use std::sync::Arc;
use tokio::sync::Mutex;
use uuid::Uuid;

use crate::contracts::Storage;
use crate::file_storage::create_file_storage;
use crate::graph_storage::GraphStorageConfig;
use crate::native_graph_storage::NativeGraphStorage;
use crate::symbol_storage::SymbolStorage;
use std::path::Path;

/// Create a production-ready symbol storage with all wrappers
///
/// DEPRECATED: Use binary symbol format (BinarySymbolWriter/Reader) instead.
/// Binary format provides superior performance compared to JSON-based SymbolStorage.
///
/// Returns a symbol storage instance wrapped with:
/// - Tracing for observability
/// - Validation for input safety
/// - Retry logic for resilience
/// - Caching for performance
///
/// # Arguments
/// * `data_dir` - Directory for storing data
/// * `cache_size` - Optional cache size (defaults to 1000)
#[deprecated(
    note = "Use BinarySymbolWriter/Reader for better performance. See ingest_with_binary_symbols_and_relationships."
)]
pub async fn create_symbol_storage(
    data_dir: &str,
    cache_size: Option<usize>,
) -> Result<Arc<Mutex<SymbolStorage>>> {
    // Create base storage with all wrappers
    let storage = create_file_storage(data_dir, cache_size).await?;

    // Create symbol storage with wrapped storage
    let symbol_storage = SymbolStorage::new(Box::new(storage)).await?;

    Ok(Arc::new(Mutex::new(symbol_storage)))
}

/// Create a test symbol storage for unit tests
///
/// DEPRECATED: Use binary symbol format for tests.
///
/// Returns a symbol storage backed by temporary directory storage
#[deprecated(note = "Use BinarySymbolWriter/Reader for tests")]
pub async fn create_test_symbol_storage() -> Result<Arc<Mutex<SymbolStorage>>> {
    // Use temporary directory for test storage
    let test_dir = format!("test_data/symbol_test_{}", Uuid::new_v4());
    tokio::fs::create_dir_all(&test_dir).await?;

    let storage = create_file_storage(&test_dir, Some(100)).await?;
    let symbol_storage = SymbolStorage::new(Box::new(storage)).await?;

    // Clean up will happen when test ends
    Ok(Arc::new(Mutex::new(symbol_storage)))
}

/// Create a symbol storage with custom underlying storage
///
/// DEPRECATED: Use binary symbol format instead.
///
/// Allows providing a custom storage implementation while still
/// getting the full symbol extraction and indexing capabilities
#[deprecated(note = "Use BinarySymbolWriter/Reader instead")]
pub async fn create_symbol_storage_with_storage(
    storage: Box<dyn Storage + Send + Sync>,
) -> Result<Arc<Mutex<SymbolStorage>>> {
    let symbol_storage = SymbolStorage::new(storage).await?;
    Ok(Arc::new(Mutex::new(symbol_storage)))
}

/// Create a symbol storage with both document and graph storage backends
///
/// DEPRECATED: Use binary symbol format with dependency_graph.bin instead.
///
/// This enables dual storage architecture for optimal performance:
/// - Document storage for symbol metadata and content
/// - Graph storage for O(1) relationship lookups
///
/// # Arguments
/// * `data_dir` - Directory for storing data
/// * `cache_size` - Optional cache size (defaults to 1000)
#[deprecated(note = "Use binary symbols.kota and dependency_graph.bin files instead")]
pub async fn create_symbol_storage_with_graph(
    data_dir: &str,
    cache_size: Option<usize>,
) -> Result<Arc<Mutex<SymbolStorage>>> {
    // Create document storage with all wrappers
    let document_storage = create_file_storage(data_dir, cache_size).await?;

    // Create graph storage for relationships
    let graph_path = Path::new(data_dir).join("graph");
    tokio::fs::create_dir_all(&graph_path).await?;
    let graph_config = GraphStorageConfig::default();
    let graph_storage = NativeGraphStorage::new(graph_path, graph_config).await?;

    // Create symbol storage with both backends
    let symbol_storage =
        SymbolStorage::with_graph_storage(Box::new(document_storage), Box::new(graph_storage))
            .await?;

    Ok(Arc::new(Mutex::new(symbol_storage)))
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_default_cache() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        let storage = create_symbol_storage(data_dir, None).await;

        assert!(storage.is_ok(), "Should successfully create symbol storage");
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_custom_cache() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        let storage = create_symbol_storage(data_dir, Some(500)).await;

        assert!(
            storage.is_ok(),
            "Should successfully create symbol storage with custom cache"
        );
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_invalid_path() {
        // Test with a path that will fail validation
        let result = create_symbol_storage("../invalid/../../path", None).await;

        assert!(result.is_err(), "Should fail with invalid path");
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_test_symbol_storage() {
        let storage = create_test_symbol_storage().await;

        assert!(
            storage.is_ok(),
            "Should successfully create test symbol storage"
        );
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock

        // Test storage should be backed by temporary directory
        // (cleanup happens automatically when test ends)
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_custom_storage() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        // Create a custom storage backend
        let custom_storage = create_file_storage(data_dir, Some(100))
            .await
            .expect("Failed to create file storage");

        let storage = create_symbol_storage_with_storage(Box::new(custom_storage)).await;

        assert!(
            storage.is_ok(),
            "Should successfully create symbol storage with custom storage"
        );
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_graph() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        let storage = create_symbol_storage_with_graph(data_dir, None).await;

        assert!(
            storage.is_ok(),
            "Should successfully create symbol storage with graph"
        );
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock

        // Verify graph directory was created
        let graph_path = Path::new(data_dir).join("graph");
        assert!(graph_path.exists(), "Graph directory should be created");
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_graph_custom_cache() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        let storage = create_symbol_storage_with_graph(data_dir, Some(2000)).await;

        assert!(
            storage.is_ok(),
            "Should successfully create symbol storage with graph and custom cache"
        );
        let storage = storage.unwrap();

        // Verify it's wrapped in Arc<Mutex<>>
        let locked = storage.lock().await;
        // Basic operation to ensure it's functional
        drop(locked); // Release lock

        // Verify graph directory was created
        let graph_path = Path::new(data_dir).join("graph");
        assert!(graph_path.exists(), "Graph directory should be created");
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_create_symbol_storage_with_graph_invalid_path() {
        // Test with a path that will fail validation
        let result = create_symbol_storage_with_graph("../invalid/../../path", None).await;

        assert!(result.is_err(), "Should fail with invalid path");
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_factory_functions_are_deprecated() {
        // This test documents that all factory functions are deprecated
        // and serves as a reminder for migration to binary symbol format

        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        // All these should work but are deprecated
        let _ = create_symbol_storage(data_dir, None).await;
        let _ = create_test_symbol_storage().await;

        let custom_storage = create_file_storage(data_dir, Some(100)).await.unwrap();
        let _ = create_symbol_storage_with_storage(Box::new(custom_storage)).await;
        let _ = create_symbol_storage_with_graph(data_dir, None).await;

        // This test passes to document that deprecated functions still work
        // Migration path: Use BinarySymbolWriter/Reader with symbols.kota and dependency_graph.bin
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_concurrent_factory_usage() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().to_str().unwrap();

        // Test that multiple factory creations work concurrently
        let handles = vec![
            tokio::spawn({
                let data_dir = data_dir.to_string();
                async move { create_symbol_storage(&data_dir, Some(100)).await }
            }),
            tokio::spawn({
                let data_dir = data_dir.to_string();
                async move { create_symbol_storage(&data_dir, Some(200)).await }
            }),
            tokio::spawn({
                let data_dir = data_dir.to_string();
                async move { create_symbol_storage_with_graph(&data_dir, Some(300)).await }
            }),
        ];

        // Wait for all to complete
        for handle in handles {
            let result = handle.await.expect("Task should complete");
            assert!(
                result.is_ok(),
                "All concurrent factory creations should succeed"
            );
        }
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_test_symbol_storage_isolation() {
        // Test that multiple test storages are isolated from each other
        let storage1 = create_test_symbol_storage()
            .await
            .expect("Should create first test storage");
        let storage2 = create_test_symbol_storage()
            .await
            .expect("Should create second test storage");

        // Both should be valid and isolated
        let _lock1 = storage1.lock().await;
        let _lock2 = storage2.lock().await;

        // Test storages should be independent (they use different UUIDs in paths)
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_factory_error_handling() {
        // Test various error conditions

        // Invalid path should fail
        let result = create_symbol_storage("/proc/invalid", None).await;
        assert!(result.is_err(), "Should fail with invalid system path");

        // Path with null bytes should fail
        let result = create_symbol_storage("test\0path", None).await;
        assert!(result.is_err(), "Should fail with null bytes in path");
    }

    #[tokio::test]
    #[allow(deprecated)]
    async fn test_factory_directory_creation() {
        let temp_dir = TempDir::new().expect("Failed to create temp directory");
        let data_dir = temp_dir.path().join("nested").join("subdirs");
        let data_dir_str = data_dir.to_str().unwrap();

        // Directory doesn't exist initially
        assert!(
            !data_dir.exists(),
            "Nested directory shouldn't exist initially"
        );

        // Factory should create necessary directories
        let storage = create_symbol_storage(data_dir_str, None).await;
        assert!(
            storage.is_ok(),
            "Should successfully create storage and directories"
        );

        // Verify directories were created
        assert!(data_dir.exists(), "Nested directory should be created");
        assert!(
            data_dir.join("documents").exists(),
            "Documents subdirectory should be created"
        );
        assert!(
            data_dir.join("indices").exists(),
            "Indices subdirectory should be created"
        );
        assert!(
            data_dir.join("wal").exists(),
            "WAL subdirectory should be created"
        );
        assert!(
            data_dir.join("meta").exists(),
            "Meta subdirectory should be created"
        );
    }
}
