---
tags:
- file
- kota-db
- ext_ts
---
/**
 * Validation Tests for KotaDB TypeScript Client
 * 
 * Comprehensive tests for validation functions that ensure security
 * and data integrity across all client operations.
 */

import {
  validateFilePath,
  validateDirectoryPath,
  validateDocumentId,
  validateTitle,
  validateTag,
  validateSearchQuery,
  validateTimestamp,
  validateSize,
  ValidationError
} from '../src/validation';

describe('validateFilePath', () => {
  test('should accept valid file paths', () => {
    const validPaths = [
      '/test.md',
      '/notes/meeting.md',
      '/deep/nested/path/document.txt',
      'relative/path.md',
      'simple.txt',
      '/path/with spaces/file.md',
      '/path/with-dashes/file.md',
      '/path/with_underscores/file.md',
      '/unicode/文档.md',
      '/emoji/📄.txt'
    ];

    for (const path of validPaths) {
      expect(() => validateFilePath(path)).not.toThrow();
    }
  });

  test('should reject empty paths', () => {
    expect(() => validateFilePath('')).toThrow(ValidationError);
    expect(() => validateFilePath('   ')).toThrow(ValidationError);
  });

  test('should reject directory traversal attempts', () => {
    const traversalPaths = [
      '../etc/passwd',
      '/legitimate/../../../etc/passwd',
      'good/path/../../bad/path',
      '..\\windows\\system32',
      '/app/../../../root/.ssh/id_rsa',
      '../',
      '..\\',
      '..//..//',
      '..\\..\\',
      './../',
      '.\\..\\.\\',
      '/path/../other',
      'path\\..\\other'
    ];

    for (const path of traversalPaths) {
      expect(() => validateFilePath(path)).toThrow(ValidationError);
      expect(() => validateFilePath(path)).toThrow('Parent directory references (..) not allowed');
    }
  });

  test('should reject null byte injection', () => {
    const nullBytePaths = [
      '/test\x00.md',
      '/legitimate/path\x00/../etc/passwd',
      '\x00malicious.txt',
      '/path/file.txt\x00.jpg',
      'normal\x00injection'
    ];

    for (const path of nullBytePaths) {
      expect(() => validateFilePath(path)).toThrow(ValidationError);
      expect(() => validateFilePath(path)).toThrow('Path contains null bytes');
    }
  });

  test('should reject Windows reserved names', () => {
    const reservedPaths = [
      'CON.txt',
      'PRN.md',
      'AUX',
      'NUL.log',
      'COM1.txt',
      'COM2.doc',
      'COM9.pdf',
      'LPT1.md',
      'LPT9.txt',
      '/path/to/CON.txt',
      '/folder/PRN',
      '/deep/path/AUX.log',
      'con.txt', // Case insensitive
      'prn.md',
      'aux',
      'nul.log'
    ];

    for (const path of reservedPaths) {
      expect(() => validateFilePath(path)).toThrow(ValidationError);
      expect(() => validateFilePath(path)).toThrow(/Reserved filename/);
    }
  });

  test('should reject paths that exceed maximum length', () => {
    const longPath = 'a'.repeat(5000);
    expect(() => validateFilePath(longPath)).toThrow(ValidationError);
    expect(() => validateFilePath(longPath)).toThrow(/Path exceeds maximum length/);
  });

  test('should accept paths at maximum length boundary', () => {
    const maxLengthPath = 'a'.repeat(4095);
    expect(() => validateFilePath(maxLengthPath)).not.toThrow();
  });
});

describe('validateDirectoryPath', () => {
  test('should accept valid directory paths', () => {
    const validDirPaths = [
      '/notes',
      '/deep/nested/directory',
      'relative/directory',
      'simple',
      '/path/with spaces',
      '/path/with-dashes',
      '/path/with_underscores'
    ];

    for (const path of validDirPaths) {
      expect(() => validateDirectoryPath(path)).not.toThrow();
    }
  });

  test('should reject paths with file extensions', () => {
    const pathsWithExtensions = [
      '/notes.md',
      '/directory/file.txt',
      'folder.pdf',
      '/path/directory.doc',
      'simple.log'
    ];

    for (const path of pathsWithExtensions) {
      expect(() => validateDirectoryPath(path)).toThrow(ValidationError);
      expect(() => validateDirectoryPath(path)).toThrow('Directory path should not have file extension');
    }
  });

  test('should inherit all file path validations', () => {
    expect(() => validateDirectoryPath('../etc')).toThrow(ValidationError);
    expect(() => validateDirectoryPath('/path\x00')).toThrow(ValidationError);
    expect(() => validateDirectoryPath('CON')).toThrow(ValidationError);
  });
});

describe('validateDocumentId', () => {
  test('should accept valid UUIDs', () => {
    const validUuids = [
      '123e4567-e89b-12d3-a456-426614174000',
      '550e8400-e29b-41d4-a716-446655440000',
      'f47ac10b-58cc-4372-a567-0e02b2c3d479',
      'A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11', // Uppercase
      '6ba7b810-9dad-11d1-80b4-00c04fd430c8',
      '6ba7b811-9dad-11d1-80b4-00c04fd430c8',
      '6ba7b812-9dad-11d1-80b4-00c04fd430c8',
      '6ba7b814-9dad-11d1-80b4-00c04fd430c8'
    ];

    for (const uuid of validUuids) {
      expect(() => validateDocumentId(uuid)).not.toThrow();
    }
  });

  test('should reject empty or whitespace-only IDs', () => {
    const emptyIds = ['', '   ', '\t\n\r'];

    for (const id of emptyIds) {
      expect(() => validateDocumentId(id)).toThrow(ValidationError);
      expect(() => validateDocumentId(id)).toThrow('Document ID cannot be empty');
    }
  });

  test('should reject malformed UUIDs', () => {
    const invalidUuids = [
      'not-a-uuid',
      '123e4567-e89b-12d3-a456',  // Too short
      '123e4567-e89b-12d3-a456-426614174000-extra',  // Too long
      '123e4567-e89b-12d3-g456-426614174000',  // Invalid hex character
      '123e4567e89b12d3a456426614174000',  // Missing dashes
      '123e4567_e89b_12d3_a456_426614174000',  // Wrong separators
      '123e4567-e89b-12d3-a456-42661417400g',  // Invalid character at end
      'G23e4567-e89b-12d3-a456-426614174000',  // Invalid character at start
      '123e4567-e89b-12d3-a456-4266141740000', // Too many digits
      '123e4567-e89b-12d3-a456-42661417400',   // Too few digits
      '123e4567-e89b-72d3-a456-426614174000',  // Invalid version (7)
      '123e4567-e89b-02d3-a456-426614174000'   // Invalid version (0)
    ];

    for (const uuid of invalidUuids) {
      expect(() => validateDocumentId(uuid)).toThrow(ValidationError);
      expect(() => validateDocumentId(uuid)).toThrow('Invalid UUID format');
    }
  });

  test('should reject nil UUID', () => {
    expect(() => validateDocumentId('00000000-0000-0000-0000-000000000000'))
      .toThrow(ValidationError);
    expect(() => validateDocumentId('00000000-0000-0000-0000-000000000000'))
      .toThrow('Document ID cannot be nil UUID');
  });

  test('should be case insensitive for valid UUIDs', () => {
    const mixedCaseUuids = [
      '123E4567-e89b-12d3-A456-426614174000',
      'F47AC10B-58cc-4372-a567-0e02b2c3d479',
      'a0eebc99-9C0B-4ef8-bb6d-6bb9bd380a11'
    ];

    for (const uuid of mixedCaseUuids) {
      expect(() => validateDocumentId(uuid)).not.toThrow();
    }
  });
});

describe('validateTitle', () => {
  test('should accept valid titles', () => {
    const validTitles = [
      'Simple Title',
      'Title with Numbers 123',
      'Title with Special Characters!@#$%^&*()',
      'Unicode Title with Émojis 🚀',
      'Very Long Title '.repeat(50), // About 850 chars
      'A'.repeat(1024) // Exactly max length
    ];

    for (const title of validTitles) {
      expect(() => validateTitle(title)).not.toThrow();
    }
  });

  test('should reject empty or whitespace-only titles', () => {
    const emptyTitles = [
      '',
      '   ',
      '\t\n\r',
      '     \t   \n   '
    ];

    for (const title of emptyTitles) {
      expect(() => validateTitle(title)).toThrow(ValidationError);
      expect(() => validateTitle(title)).toThrow('Title cannot be empty');
    }
  });

  test('should reject titles that exceed maximum length', () => {
    const longTitles = [
      'A'.repeat(1025),
      'A'.repeat(2000),
      'Very Long Title '.repeat(100) // About 1600 chars
    ];

    for (const title of longTitles) {
      expect(() => validateTitle(title)).toThrow(ValidationError);
      expect(() => validateTitle(title)).toThrow('Title exceeds maximum length of 1024 characters');
    }
  });

  test('should handle trimming for length validation', () => {
    const titleWithSpaces = ' '.repeat(10) + 'A'.repeat(1020) + ' '.repeat(10);
    expect(() => validateTitle(titleWithSpaces)).not.toThrow();

    const titleTooLongAfterTrim = ' '.repeat(10) + 'A'.repeat(1025) + ' '.repeat(10);
    expect(() => validateTitle(titleTooLongAfterTrim)).toThrow(ValidationError);
  });
});

describe('validateTag', () => {
  test('should accept valid tags', () => {
    const validTags = [
      'simple',
      'tag-with-dashes',
      'tag_with_underscores',
      'tag with spaces',
      'Tag123',
      'UPPERCASE',
      'MixedCase',
      'a1b2c3',
      'A'.repeat(128) // Max length
    ];

    for (const tag of validTags) {
      expect(() => validateTag(tag)).not.toThrow();
    }
  });

  test('should reject empty or whitespace-only tags', () => {
    const emptyTags = [
      '',
      '   ',
      '\t\n\r'
    ];

    for (const tag of emptyTags) {
      expect(() => validateTag(tag)).toThrow(ValidationError);
      expect(() => validateTag(tag)).toThrow('Tag cannot be empty');
    }
  });

  test('should reject tags that are too long', () => {
    const longTags = [
      'A'.repeat(129),
      'A'.repeat(200),
      'very-long-tag-name-that-exceeds-the-maximum-allowed-length-for-tags-in-the-kotadb-system-which-should-definitely-be-rejected-because-it-is-way-too-long'
    ];

    for (const tag of longTags) {
      expect(() => validateTag(tag)).toThrow(ValidationError);
      expect(() => validateTag(tag)).toThrow('Tag too long (max 128 chars)');
    }
  });

  test('should reject tags with invalid characters', () => {
    const invalidTags = [
      'tag@invalid',
      'tag#invalid',
      'tag$invalid',
      'tag%invalid',
      'tag^invalid',
      'tag&invalid',
      'tag*invalid',
      'tag(invalid)',
      'tag[invalid]',
      'tag{invalid}',
      'tag/invalid',
      'tag\\invalid',
      'tag|invalid',
      'tag<invalid>',
      'tag"invalid',
      'tag\'invalid',
      'tag+invalid',
      'tag=invalid',
      'tag?invalid',
      'tag:invalid',
      'tag;invalid',
      'tag,invalid',
      'tag.invalid'
    ];

    for (const tag of invalidTags) {
      expect(() => validateTag(tag)).toThrow(ValidationError);
      expect(() => validateTag(tag)).toThrow('Tag contains invalid characters');
    }
  });
});

describe('validateSearchQuery', () => {
  test('should accept valid search queries', () => {
    const validQueries = [
      'simple search',
      'search with "quotes"',
      'search with special characters: !@#$%^&*()',
      'unicode search 文档 🔍',
      'very long search query with many terms and detailed specifications',
      'A'.repeat(1024) // Max length
    ];

    for (const query of validQueries) {
      expect(() => validateSearchQuery(query)).not.toThrow();
    }
  });

  test('should reject empty or whitespace-only queries', () => {
    const emptyQueries = [
      '',
      '   ',
      '\t\n\r'
    ];

    for (const query of emptyQueries) {
      expect(() => validateSearchQuery(query)).toThrow(ValidationError);
      expect(() => validateSearchQuery(query)).toThrow('Search query cannot be empty');
    }
  });

  test('should reject queries that are too long', () => {
    const longQueries = [
      'A'.repeat(1025),
      'very long search query '.repeat(100)
    ];

    for (const query of longQueries) {
      expect(() => validateSearchQuery(query)).toThrow(ValidationError);
      expect(() => validateSearchQuery(query)).toThrow('Search query too long (max 1024 chars)');
    }
  });
});

describe('validateTimestamp', () => {
  test('should accept valid timestamps', () => {
    const validTimestamps = [
      1,
      1000000000, // 2001-09-09
      1609459200, // 2021-01-01
      1640995200, // 2022-01-01
      Math.floor(Date.now() / 1000), // Current time
      2000000000, // 2033-05-18
      Math.floor(new Date('2030-01-01').getTime() / 1000)
    ];

    for (const timestamp of validTimestamps) {
      expect(() => validateTimestamp(timestamp)).not.toThrow();
    }
  });

  test('should reject zero and negative timestamps', () => {
    const invalidTimestamps = [
      0,
      -1,
      -1000000000,
      -100
    ];

    for (const timestamp of invalidTimestamps) {
      expect(() => validateTimestamp(timestamp)).toThrow(ValidationError);
      expect(() => validateTimestamp(timestamp)).toThrow('Timestamp must be positive');
    }
  });

  test('should reject timestamps too far in the future', () => {
    const farFutureTimestamps = [
      32503680000, // Year 3000
      32503680001, // Year 3000 + 1 second
      99999999999  // Far future
    ];

    for (const timestamp of farFutureTimestamps) {
      expect(() => validateTimestamp(timestamp)).toThrow(ValidationError);
      expect(() => validateTimestamp(timestamp)).toThrow('Timestamp too far in future');
    }
  });

  test('should accept timestamps near the year 3000 boundary', () => {
    const nearBoundaryTimestamp = 32503679999; // Just before year 3000
    expect(() => validateTimestamp(nearBoundaryTimestamp)).not.toThrow();
  });
});

describe('validateSize', () => {
  test('should accept valid sizes', () => {
    const validSizes = [
      1,
      100,
      1024,
      1024 * 1024, // 1MB
      10 * 1024 * 1024, // 10MB
      100 * 1024 * 1024 // 100MB (max)
    ];

    for (const size of validSizes) {
      expect(() => validateSize(size)).not.toThrow();
    }
  });

  test('should reject zero and negative sizes', () => {
    const invalidSizes = [
      0,
      -1,
      -100,
      -1024
    ];

    for (const size of invalidSizes) {
      expect(() => validateSize(size)).toThrow(ValidationError);
      expect(() => validateSize(size)).toThrow('Size must be greater than zero');
    }
  });

  test('should reject sizes that exceed maximum', () => {
    const tooLargeSizes = [
      100 * 1024 * 1024 + 1, // 100MB + 1 byte
      200 * 1024 * 1024,     // 200MB
      1024 * 1024 * 1024     // 1GB
    ];

    for (const size of tooLargeSizes) {
      expect(() => validateSize(size)).toThrow(ValidationError);
      expect(() => validateSize(size)).toThrow('Size exceeds maximum (100MB)');
    }
  });
});

describe('ValidationError', () => {
  test('should be an instance of Error', () => {
    const error = new ValidationError('Test message');
    expect(error).toBeInstanceOf(Error);
    expect(error).toBeInstanceOf(ValidationError);
  });

  test('should have correct name', () => {
    const error = new ValidationError('Test message');
    expect(error.name).toBe('ValidationError');
  });

  test('should preserve message', () => {
    const message = 'Custom validation error message';
    const error = new ValidationError(message);
    expect(error.message).toBe(message);
  });

  test('should be throwable and catchable', () => {
    expect(() => {
      throw new ValidationError('Test error');
    }).toThrow(ValidationError);

    try {
      throw new ValidationError('Test error');
    } catch (error) {
      expect(error).toBeInstanceOf(ValidationError);
      expect((error as ValidationError).message).toBe('Test error');
    }
  });
});