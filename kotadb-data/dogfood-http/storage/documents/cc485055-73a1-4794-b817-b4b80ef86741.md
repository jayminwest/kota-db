---
tags:
- file
- kota-db
- ext_rs
---
//! Graph-based storage backend for code intelligence features
//!
//! This module provides a specialized storage implementation optimized for
//! graph operations such as dependency tracking, call graphs, and impact analysis.
//! It complements the document-based FileStorage for a dual storage architecture.

use anyhow::Result;
use async_trait::async_trait;
use petgraph::Direction;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

use crate::contracts::Storage;
use crate::types::RelationType;

/// Extended storage trait for graph-specific operations
#[async_trait]
pub trait GraphStorage: Storage {
    /// Store a node (symbol) in the graph
    async fn store_node(&mut self, node_id: Uuid, node_data: GraphNode) -> Result<()>;

    /// Retrieve a node by ID
    async fn get_node(&self, node_id: Uuid) -> Result<Option<GraphNode>>;

    /// Store an edge (relationship) between two nodes
    async fn store_edge(&mut self, from: Uuid, to: Uuid, edge: GraphEdge) -> Result<()>;

    /// Get all edges for a node in a specific direction
    async fn get_edges(&self, node: Uuid, direction: Direction) -> Result<Vec<(Uuid, GraphEdge)>>;

    /// Get a subgraph starting from specified roots up to a certain depth
    async fn get_subgraph(&self, roots: &[Uuid], max_depth: usize) -> Result<GraphSubset>;

    /// Find all paths between two nodes (up to a maximum number)
    async fn find_paths(&self, from: Uuid, to: Uuid, max_paths: usize) -> Result<Vec<GraphPath>>;

    /// Get nodes by type (e.g., all functions, all classes)
    async fn get_nodes_by_type(&self, node_type: &str) -> Result<Vec<Uuid>>;

    /// Update edge metadata without recreating the edge
    /// Updates all edges between the two nodes with the given metadata
    async fn update_edge_metadata(
        &mut self,
        from: Uuid,
        to: Uuid,
        metadata: HashMap<String, String>,
    ) -> Result<()>;

    /// Update edge metadata for a specific relationship type
    async fn update_edge_metadata_by_type(
        &mut self,
        from: Uuid,
        to: Uuid,
        relation_type: RelationType,
        metadata: HashMap<String, String>,
    ) -> Result<()>;

    /// Remove all edges between two nodes
    async fn remove_edge(&mut self, from: Uuid, to: Uuid) -> Result<bool>;

    /// Remove a specific edge by relationship type
    async fn remove_edge_by_type(
        &mut self,
        from: Uuid,
        to: Uuid,
        relation_type: RelationType,
    ) -> Result<bool>;

    /// Delete a node and all its edges
    async fn delete_node(&mut self, node_id: Uuid) -> Result<bool>;

    /// Get graph statistics
    async fn get_graph_stats(&self) -> Result<GraphStats>;

    /// Perform batch operations for efficiency
    async fn batch_insert_nodes(&mut self, nodes: Vec<(Uuid, GraphNode)>) -> Result<()>;
    async fn batch_insert_edges(&mut self, edges: Vec<(Uuid, Uuid, GraphEdge)>) -> Result<()>;
}

/// Node representation in the graph storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphNode {
    /// Unique identifier
    pub id: Uuid,
    /// Node type (e.g., "function", "class", "module")
    pub node_type: String,
    /// Qualified name (e.g., "kotadb::storage::FileStorage")
    pub qualified_name: String,
    /// File path containing this node
    pub file_path: String,
    /// Line and column information
    pub location: NodeLocation,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
    /// Timestamp of last update
    pub updated_at: i64,
}

/// Location information for a node
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeLocation {
    pub start_line: usize,
    pub start_column: usize,
    pub end_line: usize,
    pub end_column: usize,
}

/// Edge representation in the graph storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphEdge {
    /// Type of relationship
    pub relation_type: RelationType,
    /// Location where the relationship occurs
    pub location: NodeLocation,
    /// Context snippet
    pub context: Option<String>,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
    /// Timestamp of edge creation
    pub created_at: i64,
}

/// Subset of the graph returned by queries
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphSubset {
    /// Nodes in the subset
    pub nodes: HashMap<Uuid, GraphNode>,
    /// Edges in the subset (from_id -> [(to_id, edge)])
    pub edges: HashMap<Uuid, Vec<(Uuid, GraphEdge)>>,
    /// Query metadata
    pub metadata: QueryMetadata,
}

/// Path through the graph
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphPath {
    /// Sequence of node IDs in the path
    pub nodes: Vec<Uuid>,
    /// Edges along the path
    pub edges: Vec<GraphEdge>,
    /// Total path length
    pub length: usize,
}

/// Query metadata for performance tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueryMetadata {
    /// Number of nodes visited during query
    pub nodes_visited: usize,
    /// Number of edges traversed
    pub edges_traversed: usize,
    /// Query execution time in microseconds
    pub execution_time_us: u64,
    /// Whether the query was truncated due to limits
    pub truncated: bool,
}

/// Statistics about the graph
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphStats {
    /// Total number of nodes
    pub node_count: usize,
    /// Total number of edges
    pub edge_count: usize,
    /// Node count by type
    pub nodes_by_type: HashMap<String, usize>,
    /// Edge count by relation type
    pub edges_by_type: HashMap<String, usize>,
    /// Average in-degree
    pub avg_in_degree: f64,
    /// Average out-degree
    pub avg_out_degree: f64,
    /// Number of connected components
    pub connected_components: usize,
    /// Storage size in bytes
    pub storage_size_bytes: u64,
}

/// Configuration for graph storage backend
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphStorageConfig {
    /// Maximum number of nodes to keep in memory cache
    pub cache_size: usize,
    /// Enable write-ahead logging
    pub enable_wal: bool,
    /// Compression type for storage
    pub compression: CompressionType,
    /// Sync mode for durability
    pub sync_mode: SyncMode,
    /// Maximum depth for traversal queries
    pub max_traversal_depth: usize,
    /// Maximum number of paths to return in path queries
    pub max_path_results: usize,
}

impl Default for GraphStorageConfig {
    fn default() -> Self {
        Self {
            cache_size: 10_000,
            enable_wal: true,
            compression: CompressionType::Snappy,
            sync_mode: SyncMode::Normal,
            max_traversal_depth: 10,
            max_path_results: 1000,
        }
    }
}

/// Compression types for storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CompressionType {
    None,
    Snappy,
    Zstd,
    Lz4,
}

/// Sync modes for durability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncMode {
    /// Sync on every write (slowest, most durable)
    Full,
    /// Sync periodically (balanced)
    Normal,
    /// Minimal syncing (fastest, least durable)
    Fast,
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use uuid::Uuid;

    fn create_test_node_location() -> NodeLocation {
        NodeLocation {
            start_line: 10,
            start_column: 5,
            end_line: 15,
            end_column: 20,
        }
    }

    fn create_test_graph_node() -> GraphNode {
        GraphNode {
            id: Uuid::new_v4(),
            qualified_name: "test_function".to_string(),
            node_type: "function".to_string(),
            file_path: "src/test.rs".to_string(),
            location: create_test_node_location(),
            metadata: {
                let mut map = HashMap::new();
                map.insert("visibility".to_string(), "public".to_string());
                map
            },
            updated_at: Utc::now().timestamp(),
        }
    }

    fn create_test_graph_edge() -> GraphEdge {
        GraphEdge {
            relation_type: RelationType::Calls,
            location: create_test_node_location(),
            context: Some("function_call()".to_string()),
            metadata: HashMap::new(),
            created_at: Utc::now().timestamp(),
        }
    }

    #[test]
    fn test_node_location_creation() {
        let location = create_test_node_location();
        assert_eq!(location.start_line, 10);
        assert_eq!(location.start_column, 5);
        assert_eq!(location.end_line, 15);
        assert_eq!(location.end_column, 20);
    }

    #[test]
    fn test_node_location_serialization() {
        let location = create_test_node_location();
        let serialized = serde_json::to_string(&location).expect("Failed to serialize");
        let deserialized: NodeLocation =
            serde_json::from_str(&serialized).expect("Failed to deserialize");

        assert_eq!(location.start_line, deserialized.start_line);
        assert_eq!(location.start_column, deserialized.start_column);
        assert_eq!(location.end_line, deserialized.end_line);
        assert_eq!(location.end_column, deserialized.end_column);
    }

    #[test]
    fn test_graph_node_creation() {
        let node = create_test_graph_node();
        assert_eq!(node.qualified_name, "test_function");
        assert_eq!(node.node_type, "function");
        assert_eq!(node.file_path, "src/test.rs");
        assert!(node.metadata.contains_key("visibility"));
        assert_eq!(node.metadata["visibility"], "public");
    }

    #[test]
    fn test_graph_node_serialization() {
        let node = create_test_graph_node();
        let serialized = serde_json::to_string(&node).expect("Failed to serialize");
        let deserialized: GraphNode =
            serde_json::from_str(&serialized).expect("Failed to deserialize");

        assert_eq!(node.qualified_name, deserialized.qualified_name);
        assert_eq!(node.node_type, deserialized.node_type);
        assert_eq!(node.file_path, deserialized.file_path);
        assert_eq!(node.metadata, deserialized.metadata);
    }

    #[test]
    fn test_graph_edge_creation() {
        let edge = create_test_graph_edge();
        assert_eq!(edge.relation_type, RelationType::Calls);
        assert_eq!(edge.context, Some("function_call()".to_string()));
        assert!(edge.metadata.is_empty());
    }

    #[test]
    fn test_graph_edge_serialization() {
        let edge = create_test_graph_edge();
        let serialized = serde_json::to_string(&edge).expect("Failed to serialize");
        let deserialized: GraphEdge =
            serde_json::from_str(&serialized).expect("Failed to deserialize");

        assert_eq!(edge.relation_type, deserialized.relation_type);
        assert_eq!(edge.context, deserialized.context);
        assert_eq!(edge.metadata, deserialized.metadata);
    }

    #[test]
    fn test_graph_subset_creation() {
        let node_id = Uuid::new_v4();
        let node = create_test_graph_node();
        let edge = create_test_graph_edge();

        let mut nodes = HashMap::new();
        nodes.insert(node_id, node);

        let mut edges = HashMap::new();
        edges.insert(node_id, vec![(Uuid::new_v4(), edge)]);

        let metadata = QueryMetadata {
            nodes_visited: 5,
            edges_traversed: 3,
            execution_time_us: 42000,
            truncated: false,
        };

        let subset = GraphSubset {
            nodes,
            edges,
            metadata,
        };

        assert_eq!(subset.nodes.len(), 1);
        assert_eq!(subset.edges.len(), 1);
        assert_eq!(subset.metadata.nodes_visited, 5);
        assert_eq!(subset.metadata.execution_time_us, 42000);
    }

    #[test]
    fn test_graph_path_creation() {
        let node1 = Uuid::new_v4();
        let node2 = Uuid::new_v4();
        let edge = create_test_graph_edge();

        let path = GraphPath {
            nodes: vec![node1, node2],
            edges: vec![edge],
            length: 2,
        };

        assert_eq!(path.nodes.len(), 2);
        assert_eq!(path.edges.len(), 1);
        assert_eq!(path.length, 2);
    }

    #[test]
    fn test_query_metadata_creation() {
        let metadata = QueryMetadata {
            nodes_visited: 100,
            edges_traversed: 250,
            execution_time_us: 123000,
            truncated: false,
        };

        assert_eq!(metadata.nodes_visited, 100);
        assert_eq!(metadata.edges_traversed, 250);
        assert_eq!(metadata.execution_time_us, 123000);
        assert!(!metadata.truncated);
    }

    #[test]
    fn test_graph_storage_config_default() {
        let config = GraphStorageConfig::default();
        assert_eq!(config.cache_size, 10_000);
        assert!(config.enable_wal);
        assert_eq!(config.max_traversal_depth, 10);
        assert_eq!(config.max_path_results, 1000);

        // Test enum variants
        match config.compression {
            CompressionType::Snappy => {}
            _ => panic!("Expected Snappy compression as default"),
        }

        match config.sync_mode {
            SyncMode::Normal => {}
            _ => panic!("Expected Normal sync mode as default"),
        }
    }

    #[test]
    fn test_graph_storage_config_customization() {
        let config = GraphStorageConfig {
            cache_size: 5000,
            enable_wal: false,
            compression: CompressionType::Zstd,
            sync_mode: SyncMode::Fast,
            max_traversal_depth: 5,
            max_path_results: 500,
        };

        assert_eq!(config.cache_size, 5000);
        assert!(!config.enable_wal);
        assert_eq!(config.max_traversal_depth, 5);
        assert_eq!(config.max_path_results, 500);

        match config.compression {
            CompressionType::Zstd => {}
            _ => panic!("Expected Zstd compression"),
        }

        match config.sync_mode {
            SyncMode::Fast => {}
            _ => panic!("Expected Fast sync mode"),
        }
    }

    #[test]
    fn test_compression_type_variants() {
        let none = CompressionType::None;
        let snappy = CompressionType::Snappy;
        let zstd = CompressionType::Zstd;
        let lz4 = CompressionType::Lz4;

        // Test serialization of enum variants
        assert!(serde_json::to_string(&none).is_ok());
        assert!(serde_json::to_string(&snappy).is_ok());
        assert!(serde_json::to_string(&zstd).is_ok());
        assert!(serde_json::to_string(&lz4).is_ok());
    }

    #[test]
    fn test_sync_mode_variants() {
        let full = SyncMode::Full;
        let normal = SyncMode::Normal;
        let fast = SyncMode::Fast;

        // Test serialization of enum variants
        assert!(serde_json::to_string(&full).is_ok());
        assert!(serde_json::to_string(&normal).is_ok());
        assert!(serde_json::to_string(&fast).is_ok());
    }

    #[test]
    fn test_graph_node_with_empty_metadata() {
        let node = GraphNode {
            id: Uuid::new_v4(),
            qualified_name: "simple_function".to_string(),
            node_type: "function".to_string(),
            file_path: "src/simple.rs".to_string(),
            location: create_test_node_location(),
            metadata: HashMap::new(),
            updated_at: Utc::now().timestamp(),
        };

        assert_eq!(node.qualified_name, "simple_function");
        assert!(node.metadata.is_empty());
    }

    #[test]
    fn test_graph_edge_with_metadata() {
        let mut metadata = HashMap::new();
        metadata.insert("confidence".to_string(), "high".to_string());
        metadata.insert("weight".to_string(), "0.95".to_string());

        let edge = GraphEdge {
            relation_type: RelationType::Calls,
            location: create_test_node_location(),
            context: Some("api_call()".to_string()),
            metadata,
            created_at: Utc::now().timestamp(),
        };

        assert_eq!(edge.metadata.len(), 2);
        assert_eq!(edge.metadata["confidence"], "high");
        assert_eq!(edge.metadata["weight"], "0.95");
    }

    #[test]
    fn test_empty_graph_subset() {
        let metadata = QueryMetadata {
            nodes_visited: 0,
            edges_traversed: 0,
            execution_time_us: 1000,
            truncated: false,
        };

        let subset = GraphSubset {
            nodes: HashMap::new(),
            edges: HashMap::new(),
            metadata,
        };

        assert_eq!(subset.nodes.len(), 0);
        assert_eq!(subset.edges.len(), 0);
        assert_eq!(subset.metadata.nodes_visited, 0);
        assert_eq!(subset.metadata.edges_traversed, 0);
    }

    #[test]
    fn test_single_node_path() {
        let node = Uuid::new_v4();

        let path = GraphPath {
            nodes: vec![node],
            edges: vec![],
            length: 1,
        };

        assert_eq!(path.nodes.len(), 1);
        assert_eq!(path.edges.len(), 0);
        assert_eq!(path.length, 1);
    }

    #[test]
    fn test_complex_graph_subset_serialization() {
        let node_id1 = Uuid::new_v4();
        let node_id2 = Uuid::new_v4();

        let mut nodes = HashMap::new();
        nodes.insert(node_id1, create_test_graph_node());
        nodes.insert(node_id2, create_test_graph_node());

        let mut edges = HashMap::new();
        edges.insert(node_id1, vec![(node_id2, create_test_graph_edge())]);

        let metadata = QueryMetadata {
            nodes_visited: 2,
            edges_traversed: 1,
            execution_time_us: 5000,
            truncated: false,
        };

        let subset = GraphSubset {
            nodes,
            edges,
            metadata,
        };

        let serialized = serde_json::to_string(&subset).expect("Failed to serialize");
        let deserialized: GraphSubset =
            serde_json::from_str(&serialized).expect("Failed to deserialize");

        assert_eq!(deserialized.nodes.len(), 2);
        assert_eq!(deserialized.edges.len(), 1);
        assert_eq!(deserialized.metadata.nodes_visited, 2);
    }
}
