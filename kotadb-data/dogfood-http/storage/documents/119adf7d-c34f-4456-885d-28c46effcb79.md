---
tags:
- file
- kota-db
- ext_ts
---
/**
 * Client Builder Integration Tests for KotaDB TypeScript Client
 * 
 * Tests for the new builder-based methods in the KotaDB client that
 * provide type safety and validation.
 */

import { KotaDB } from '../src/client';
import { DocumentBuilder, QueryBuilder } from '../src/builders';
import { 
  ValidationError,
  NotFoundError,
  KotaDBError
} from '../src/types';

// Test configuration
const TEST_PORT = process.env.KOTADB_TEST_PORT || '18432';
const TEST_SERVER_URL = process.env.KOTADB_TEST_URL || `http://localhost:${TEST_PORT}`;

describe('KotaDB Client Builder Integration', () => {
  let db: KotaDB;
  let serverAvailable = false;

  beforeAll(async () => {
    try {
      db = new KotaDB({ url: TEST_SERVER_URL });
      await db.testConnection();
      serverAvailable = true;
    } catch (error) {
      console.warn(`Test server not available at ${TEST_SERVER_URL}. Integration tests will be skipped.`);
    }
  });

  describe('Document Builder Integration', () => {
    let createdDocId: string;

    test('should insert document using DocumentBuilder', async () => {
      if (!serverAvailable) return;

      const builder = new DocumentBuilder()
        .path('/test/builder-document.md')
        .title('Document Created with Builder')
        .content('This document was created using the DocumentBuilder pattern.')
        .addTag('test')
        .addTag('builder')
        .addTag('typescript')
        .addMetadata('created_by', 'test-suite')
        .addMetadata('test_type', 'builder-integration');

      createdDocId = await db.insertWithBuilder(builder);
      
      expect(createdDocId).toBeTruthy();
      expect(typeof createdDocId).toBe('string');
      expect(createdDocId).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);
    });

    test('should retrieve builder-created document', async () => {
      if (!serverAvailable || !createdDocId) return;

      const doc = await db.get(createdDocId);
      
      expect(doc.id).toBe(createdDocId);
      expect(doc.path).toBe('/test/builder-document.md');
      expect(doc.title).toBe('Document Created with Builder');
      expect(doc.content).toBe('This document was created using the DocumentBuilder pattern.');
      expect(doc.tags).toEqual(['test', 'builder', 'typescript']);
      expect(doc.metadata).toEqual({
        created_by: 'test-suite',
        test_type: 'builder-integration'
      });
    });

    test('should validate document fields through builder', async () => {
      if (!serverAvailable) return;

      const invalidBuilder1 = new DocumentBuilder()
        .title('Missing Path')
        .content('This should fail validation');

      await expect(db.insertWithBuilder(invalidBuilder1)).rejects.toThrow(ValidationError);

      const invalidBuilder2 = new DocumentBuilder()
        .path('/test/invalid.md')
        .content('Missing Title');

      await expect(db.insertWithBuilder(invalidBuilder2)).rejects.toThrow(ValidationError);

      const invalidBuilder3 = new DocumentBuilder()
        .path('/test/invalid.md')
        .title('Missing Content');

      await expect(db.insertWithBuilder(invalidBuilder3)).rejects.toThrow(ValidationError);
    });

    test('should prevent malicious paths through builder validation', async () => {
      if (!serverAvailable) return;

      const maliciousBuilder = new DocumentBuilder()
        .title('Malicious Document')
        .content('This should be blocked');

      expect(() => maliciousBuilder.path('../../../etc/passwd')).toThrow(ValidationError);
      expect(() => maliciousBuilder.path('/path\x00injection')).toThrow(ValidationError);
      expect(() => maliciousBuilder.path('CON.txt')).toThrow(ValidationError);
    });

    test('should validate tags through builder', async () => {
      if (!serverAvailable) return;

      const builder = new DocumentBuilder()
        .path('/test/tag-validation.md')
        .title('Tag Validation Test')
        .content('Testing tag validation');

      expect(() => builder.addTag('')).toThrow(ValidationError);
      expect(() => builder.addTag('invalid@tag')).toThrow(ValidationError);
      expect(() => builder.tags(['valid', 'invalid@tag'])).toThrow(ValidationError);
    });

    test('should handle array content through builder', async () => {
      if (!serverAvailable) return;

      const arrayContent = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]; // "Hello World"
      
      const builder = new DocumentBuilder()
        .path('/test/array-content.md')
        .title('Array Content Test')
        .content(arrayContent)
        .addTag('test')
        .addTag('array');

      const docId = await db.insertWithBuilder(builder);
      const doc = await db.get(docId);
      
      expect(doc.content).toBe('Hello World');
      
      // Cleanup
      await db.delete(docId);
    });

    afterAll(async () => {
      if (serverAvailable && createdDocId) {
        try {
          await db.delete(createdDocId);
        } catch (error) {
          // Ignore cleanup errors
        }
      }
    });
  });

  describe('Query Builder Integration', () => {
    const testDocs = [
      {
        path: '/test/query-builder-1.md',
        title: 'TypeScript Advanced Patterns',
        content: 'Learn advanced TypeScript patterns including generics, decorators, and conditional types.',
        tags: ['typescript', 'patterns', 'advanced']
      },
      {
        path: '/test/query-builder-2.md',
        title: 'JavaScript Performance Tips',
        content: 'Optimize your JavaScript code with these performance tips and best practices.',
        tags: ['javascript', 'performance', 'optimization']
      }
    ];

    let testDocIds: string[] = [];

    beforeAll(async () => {
      if (!serverAvailable) return;

      // Create test documents for search
      for (const doc of testDocs) {
        try {
          const docId = await db.insert(doc);
          testDocIds.push(docId);
        } catch (error) {
          console.warn('Failed to create test document:', error);
        }
      }
    });

    afterAll(async () => {
      if (!serverAvailable) return;

      // Cleanup test documents
      for (const docId of testDocIds) {
        try {
          await db.delete(docId);
        } catch (error) {
          // Continue cleanup even if some deletions fail
        }
      }
    });

    test('should search using QueryBuilder', async () => {
      if (!serverAvailable || testDocIds.length === 0) return;

      const builder = new QueryBuilder()
        .text('typescript patterns')
        .limit(10)
        .offset(0);

      const results = await db.queryWithBuilder(builder);
      
      expect(results).toHaveProperty('results');
      expect(results).toHaveProperty('total_count');
      expect(Array.isArray(results.results)).toBe(true);
    });

    test('should apply pagination through QueryBuilder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .text('test')
        .limit(5)
        .offset(0);

      const results = await db.queryWithBuilder(builder);
      
      expect(results.results.length).toBeLessThanOrEqual(5);
    });

    test('should validate query text through builder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .limit(10);

      expect(() => builder.text('')).toThrow(ValidationError);
      expect(() => builder.text('   ')).toThrow(ValidationError);
      expect(() => builder.text('A'.repeat(1025))).toThrow(ValidationError);

      await expect(db.queryWithBuilder(builder)).rejects.toThrow(ValidationError);
    });

    test('should validate limit and offset through builder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .text('valid query');

      expect(() => builder.limit(0)).toThrow(ValidationError);
      expect(() => builder.limit(-1)).toThrow(ValidationError);
      expect(() => builder.limit(100001)).toThrow(ValidationError); // Updated to match new 100,000 limit from issue #248

      expect(() => builder.offset(-1)).toThrow(ValidationError);
      expect(() => builder.offset(-100)).toThrow(ValidationError);
    });

    test('should handle tag filters through builder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .text('patterns')
        .tagFilter('typescript')
        .limit(5);

      const results = await db.queryWithBuilder(builder);
      expect(results).toHaveProperty('results');
    });

    test('should validate tag filters through builder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .text('valid query');

      expect(() => builder.tagFilter('')).toThrow(ValidationError);
      expect(() => builder.tagFilter('invalid@tag')).toThrow(ValidationError);
    });

    test('should perform semantic search with QueryBuilder if available', async () => {
      if (!serverAvailable || testDocIds.length === 0) return;

      const builder = new QueryBuilder()
        .text('programming concepts')
        .limit(5);

      try {
        const results = await db.semanticSearchWithBuilder(builder);
        expect(results).toHaveProperty('results');
        expect(Array.isArray(results.results)).toBe(true);
      } catch (error) {
        // Semantic search might not be available - that's ok
        expect(error).toBeInstanceOf(NotFoundError);
      }
    });

    test('should perform hybrid search with QueryBuilder if available', async () => {
      if (!serverAvailable || testDocIds.length === 0) return;

      const builder = new QueryBuilder()
        .text('web development patterns')
        .semanticWeight(0.6)
        .limit(5);

      try {
        const results = await db.hybridSearchWithBuilder(builder);
        expect(results).toHaveProperty('results');
        expect(Array.isArray(results.results)).toBe(true);
      } catch (error) {
        // Hybrid search might not be available - that's ok
        expect(error).toBeInstanceOf(NotFoundError);
      }
    });

    test('should validate semantic weight through builder', async () => {
      if (!serverAvailable) return;

      const builder = new QueryBuilder()
        .text('valid query');

      expect(() => builder.semanticWeight(-0.1)).toThrow(ValidationError);
      expect(() => builder.semanticWeight(1.1)).toThrow(ValidationError);
      expect(() => builder.semanticWeight(2.0)).toThrow(ValidationError);

      // Valid weights should not throw
      expect(() => builder.semanticWeight(0.0)).not.toThrow();
      expect(() => builder.semanticWeight(0.5)).not.toThrow();
      expect(() => builder.semanticWeight(1.0)).not.toThrow();
    });
  });

  describe('Builder vs Traditional API Compatibility', () => {
    test('should produce equivalent results for document insertion', async () => {
      if (!serverAvailable) return;

      const documentData = {
        path: '/test/compatibility-traditional.md',
        title: 'Compatibility Test Traditional',
        content: 'Testing compatibility between traditional and builder APIs.',
        tags: ['test', 'compatibility'],
        metadata: { test_type: 'traditional' }
      };

      const builderData = new DocumentBuilder()
        .path('/test/compatibility-builder.md')
        .title('Compatibility Test Builder')
        .content('Testing compatibility between traditional and builder APIs.')
        .addTag('test')
        .addTag('compatibility')
        .addMetadata('test_type', 'builder');

      try {
        const traditionalDocId = await db.insert(documentData);
        const builderDocId = await db.insertWithBuilder(builderData);

        const traditionalDoc = await db.get(traditionalDocId);
        const builderDoc = await db.get(builderDocId);

        // Both should have similar structure
        expect(traditionalDoc).toHaveProperty('id');
        expect(builderDoc).toHaveProperty('id');
        expect(traditionalDoc).toHaveProperty('created_at');
        expect(builderDoc).toHaveProperty('created_at');
        expect(traditionalDoc.tags).toEqual(['test', 'compatibility']);
        expect(builderDoc.tags).toEqual(['test', 'compatibility']);

        // Cleanup
        await db.delete(traditionalDocId);
        await db.delete(builderDocId);
      } catch (error) {
        console.warn('Compatibility test failed:', error);
      }
    });

    test('should produce equivalent results for search queries', async () => {
      if (!serverAvailable) return;

      const searchTerm = 'test compatibility';
      const searchOptions = { limit: 5, offset: 0 };

      const builderQuery = new QueryBuilder()
        .text(searchTerm)
        .limit(5)
        .offset(0);

      try {
        const traditionalResults = await db.query(searchTerm, searchOptions);
        const builderResults = await db.queryWithBuilder(builderQuery);

        // Results should have same structure
        expect(traditionalResults).toHaveProperty('results');
        expect(builderResults).toHaveProperty('results');
        expect(traditionalResults).toHaveProperty('total_count');
        expect(builderResults).toHaveProperty('total_count');
        expect(Array.isArray(traditionalResults.results)).toBe(true);
        expect(Array.isArray(builderResults.results)).toBe(true);
      } catch (error) {
        console.warn('Search compatibility test failed:', error);
      }
    });
  });

  describe('Builder Error Handling', () => {
    test('should handle builder validation errors gracefully', async () => {
      if (!serverAvailable) return;

      // Test that builder validation errors are properly caught and handled
      const invalidBuilder = new DocumentBuilder()
        .title('Valid Title')
        .content('Valid Content');

      try {
        await db.insertWithBuilder(invalidBuilder);
        fail('Should have thrown validation error');
      } catch (error) {
        expect(error).toBeInstanceOf(ValidationError);
        expect((error as ValidationError).message).toContain('Document path is required');
      }
    });

    test('should handle query builder validation errors gracefully', async () => {
      if (!serverAvailable) return;

      const invalidBuilder = new QueryBuilder()
        .limit(10)
        .offset(0);

      try {
        await db.queryWithBuilder(invalidBuilder);
        fail('Should have thrown validation error');
      } catch (error) {
        expect(error).toBeInstanceOf(ValidationError);
        expect((error as ValidationError).message).toContain('Query text is required');
      }
    });
  });
});