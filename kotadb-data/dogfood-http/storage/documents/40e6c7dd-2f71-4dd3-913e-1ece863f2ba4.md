---
tags:
- file
- kota-db
- ext_rs
---
use anyhow::Result;
use kotadb::{DocumentBuilder, ValidatedPath};

#[test]
fn test_path_traversal_prevention() -> Result<()> {
    // Test various path traversal attempts
    let dangerous_paths = vec![
        "../../../etc/passwd",
        "../../sensitive/data.txt",
        "/etc/passwd",
        "/usr/bin/secret",
        "documents/../../../etc/shadow",
        "./../../config",
        "..\\..\\windows\\system32",                    // Windows style
        "documents/..\\..\\..\\etc\\passwd",            // Mixed separators
        "documents/../../../../../../../../etc/passwd", // Deep traversal
        "../",
        "..",
    ];

    for path in &dangerous_paths {
        // Test ValidatedPath
        let result = ValidatedPath::new(path);
        assert!(
            result.is_err(),
            "ValidatedPath::new should reject path: {}",
            path
        );

        // Test DocumentBuilder path validation
        let builder_result = DocumentBuilder::new()
            .path(path)
            .and_then(|b| b.title("Test"))
            .map(|b| b.content(b"test"))
            .and_then(|b| b.build());

        assert!(
            builder_result.is_err(),
            "DocumentBuilder should reject path: {}",
            path
        );
    }

    // Test that absolute paths are also rejected (should not allow access outside storage dir)
    let absolute_paths = vec![
        "/etc/passwd",
        "/home/user/.ssh/id_rsa",
        "C:\\Windows\\System32\\config\\sam",
        "/var/log/auth.log",
    ];

    for path in &absolute_paths {
        let result = ValidatedPath::new(path);
        // Note: Currently absolute paths may be allowed, which is a security issue
        // This test documents the expected behavior
        println!("Absolute path '{}' validation result: {:?}", path, result);
    }

    Ok(())
}

#[test]
fn test_valid_paths_allowed() -> Result<()> {
    // Test that legitimate paths are still allowed
    let valid_paths = vec![
        "documents/readme.md",
        "data/config.json",
        "notes/2024/january.md",
        "project/src/main.rs",
        "relative/path/file.txt",
    ];

    for path in &valid_paths {
        let result = ValidatedPath::new(path);
        assert!(
            result.is_ok(),
            "ValidatedPath::new should accept valid path: {}",
            path
        );

        let builder_result = DocumentBuilder::new()
            .path(path)
            .and_then(|b| b.title("Test"))
            .map(|b| b.content(b"test"))
            .and_then(|b| b.build());

        assert!(
            builder_result.is_ok(),
            "DocumentBuilder should accept valid path: {}",
            path
        );
    }

    Ok(())
}

#[test]
fn test_symlink_and_special_chars() -> Result<()> {
    // Test paths with special characters that might be used in attacks
    let special_paths = vec![
        "file\0name.txt",                 // Null byte injection
        "file%00name.txt",                // URL encoded null
        "file\nname.txt",                 // Newline injection
        "file\rname.txt",                 // Carriage return
        "../../%2e%2e/%2e%2e/etc/passwd", // URL encoded traversal
        "....//....//etc/passwd",         // Alternative traversal
        "file:///etc/passwd",             // File URL scheme
    ];

    for path in &special_paths {
        let result = ValidatedPath::new(path);
        if !path.contains('\0') {
            // Paths with actual null bytes should definitely fail
            println!("Special char path '{}' validation: {:?}", path, result);
        } else {
            assert!(
                result.is_err(),
                "Path with null byte should be rejected: {:?}",
                path
            );
        }
    }

    Ok(())
}
