---
tags:
- file
- kota-db
- ext_rs
---
//! Integration tests for API key authentication system
//!
//! Tests database failures, concurrent rate limiting, malformed input,
//! and IP restriction enforcement.

#[cfg(test)]
mod tests {
    use kotadb::api_keys::{ApiKeyConfig, ApiKeyService, CreateApiKeyRequest};
    use std::sync::Arc;
    use uuid::Uuid;

    /// Test API key generation uses cryptographic randomness
    #[test]
    fn test_api_key_cryptographic_randomness() {
        // Generate multiple keys and ensure they're unique
        let mut keys = std::collections::HashSet::new();
        for _ in 0..100 {
            let key = kotadb::api_keys::ApiKeyService::generate_api_key();
            assert!(
                keys.insert(key),
                "Duplicate key generated - RNG may be weak"
            );
        }

        // Verify key format
        for key in keys.iter() {
            assert!(key.starts_with("kdb_live_"));
            assert!(key.len() > 40); // Should be significantly longer than prefix
        }
    }

    /// Test database connection failure handling
    #[tokio::test]
    async fn test_database_connection_failure() {
        let config = ApiKeyConfig {
            database_url: "postgresql://invalid:invalid@nonexistent:5432/test".to_string(),
            max_connections: 1,
            connect_timeout_seconds: 1,
            default_rate_limit: 60,
            default_monthly_quota: 1000000,
        };

        let result = ApiKeyService::new(config).await;
        assert!(result.is_err(), "Should fail with invalid database URL");

        let error_msg = result.unwrap_err().to_string();
        assert!(
            error_msg.contains("Failed to connect") || error_msg.contains("PostgreSQL"),
            "Error should indicate database connection failure"
        );
    }

    /// Test concurrent rate limiting doesn't have race conditions
    #[tokio::test]
    #[ignore] // Requires actual PostgreSQL database
    async fn test_concurrent_rate_limiting() {
        // This test would require a test database setup
        // Simulating the test structure for demonstration

        let config = ApiKeyConfig::default();
        let service = Arc::new(ApiKeyService::new(config).await.unwrap());

        // Create test API key
        let request = CreateApiKeyRequest {
            user_email: "test@example.com".to_string(),
            user_id: Some(Uuid::new_v4().to_string()),
            description: Some("Test key".to_string()),
            rate_limit: Some(10), // Low limit for testing
            monthly_quota: Some(1000),
            expires_at: None,
            allowed_ips: None,
        };

        let api_key_response = service.create_api_key(request).await.unwrap();
        let key_id = api_key_response.key_id;

        // Spawn multiple concurrent requests
        let mut handles = vec![];
        for _ in 0..20 {
            let service_clone = service.clone();
            let handle =
                tokio::spawn(async move { service_clone.check_rate_limit(key_id, 10).await });
            handles.push(handle);
        }

        // Collect results
        let mut successes = 0;
        let mut failures = 0;
        for handle in handles {
            match handle.await.unwrap() {
                Ok(true) => successes += 1,
                Ok(false) => failures += 1,
                Err(_) => failures += 1,
            }
        }

        // Exactly 10 should succeed (the rate limit)
        assert_eq!(successes, 10, "Rate limit should allow exactly 10 requests");
        assert_eq!(failures, 10, "Rate limit should block 10 requests");
    }

    /// Test API key validation with malformed input
    #[tokio::test]
    async fn test_malformed_api_key_validation() {
        let config = ApiKeyConfig::default();

        // Test with database that won't connect (expected to fail at service creation)
        let invalid_config = ApiKeyConfig {
            database_url: "not-a-valid-url".to_string(),
            ..config
        };

        let result = ApiKeyService::new(invalid_config).await;
        assert!(result.is_err(), "Should reject invalid database URL");
    }

    /// Test various malformed API key formats
    #[test]
    fn test_malformed_api_key_formats() {
        use axum::http::HeaderMap;
        use axum::http::HeaderValue;
        use kotadb::auth_middleware::extract_api_key;

        // Test empty header
        let headers = HeaderMap::new();
        assert!(extract_api_key(&headers).is_none());

        // Test invalid Bearer format
        let mut headers = HeaderMap::new();
        headers.insert("Authorization", HeaderValue::from_static("Bearer"));
        assert!(extract_api_key(&headers).is_none());

        // Test SQL injection attempt in API key
        let mut headers = HeaderMap::new();
        headers.insert(
            "X-API-Key",
            HeaderValue::from_static("'; DROP TABLE api_keys; --"),
        );
        let key = extract_api_key(&headers);
        assert_eq!(key, Some("'; DROP TABLE api_keys; --".to_string()));
        // The key will be hashed before any database operation, preventing injection
    }

    /// Test IP restriction enforcement
    #[tokio::test]
    #[ignore] // Requires actual PostgreSQL database
    async fn test_ip_restriction_enforcement() {
        let config = ApiKeyConfig::default();
        let service = ApiKeyService::new(config).await.unwrap();

        // Create API key with IP restrictions
        let request = CreateApiKeyRequest {
            user_email: "test@example.com".to_string(),
            user_id: Some(Uuid::new_v4().to_string()),
            description: Some("IP restricted key".to_string()),
            rate_limit: Some(60),
            monthly_quota: Some(1000),
            expires_at: None,
            allowed_ips: Some(vec!["192.168.1.1".to_string()]),
        };

        let api_key_response = service.create_api_key(request).await.unwrap();

        // Test validation from allowed IP
        let validation_allowed = service
            .validate_api_key(&api_key_response.api_key, Some("192.168.1.1"))
            .await
            .unwrap();
        assert!(
            validation_allowed.is_valid,
            "Should allow from whitelisted IP"
        );

        // Test validation from blocked IP
        let validation_blocked = service
            .validate_api_key(&api_key_response.api_key, Some("10.0.0.1"))
            .await
            .unwrap();
        assert!(
            !validation_blocked.is_valid,
            "Should block non-whitelisted IP"
        );
        assert_eq!(
            validation_blocked.rejection_reason,
            Some("IP address not allowed for this key".to_string())
        );
    }

    /// Test rate limit window edge cases
    #[test]
    fn test_rate_limit_window_calculation() {
        use chrono::{DateTime, Utc};

        // Test that window calculation doesn't panic or produce invalid timestamps
        let now = Utc::now();
        let current_minute = now.timestamp() / 60 * 60;

        // This should always produce a valid timestamp
        let window_timestamp = DateTime::from_timestamp(current_minute, 0);
        assert!(
            window_timestamp.is_some(),
            "Window timestamp should be valid"
        );

        // Test edge case with very old timestamp
        let old_minute = 0i64; // Unix epoch
        let old_window = DateTime::from_timestamp(old_minute, 0);
        assert!(old_window.is_some(), "Should handle epoch timestamp");

        // Test edge case with future timestamp
        let future_minute = (now.timestamp() + 86400) / 60 * 60; // Tomorrow
        let future_window = DateTime::from_timestamp(future_minute, 0);
        assert!(future_window.is_some(), "Should handle future timestamp");
    }

    /// Test error correlation IDs are generated
    #[test]
    fn test_error_correlation_ids() {
        use kotadb::auth_middleware::AuthError;

        // Create an error with correlation ID
        let error = AuthError {
            error: "test_error".to_string(),
            message: format!("Test error. Error ID: {}", Uuid::new_v4()),
            status_code: 500,
        };

        // Verify error message contains UUID pattern
        assert!(error.message.contains("Error ID: "));

        // Extract and validate UUID format
        if let Some(id_part) = error.message.split("Error ID: ").nth(1) {
            // Try to parse as UUID to verify format
            let uuid_result = Uuid::parse_str(id_part);
            assert!(uuid_result.is_ok(), "Error ID should be a valid UUID");
        }
    }
}
