---
tags:
- file
- kota-db
- ext_md
---
# Cargo Nextest Archive Migration Analysis for KotaDB CI

## Executive Summary

**Recommendation: MIGRATE TO NEXTEST ARCHIVE** - The benefits significantly outweigh the migration complexity. Expected CI time reduction from current 40+ minutes to under 15 minutes total.

## Current State Analysis

### Problem Summary
- **Build Phase**: Successfully compiles all artifacts in 10m2s ‚úÖ
- **Test Phases**: FAIL - Each test job recompiles everything (14+ minutes) ‚ùå
- **Root Cause**: Missing Cargo fingerprint data prevents dependency resolution
- **Total Pipeline Time**: ~40-45 minutes (should be ~15 minutes)
- **Wasted Compute**: 30+ minutes of redundant compilation across 5 parallel jobs

### Current Approach Limitations
1. Manual artifact packaging misses critical Cargo metadata
2. `.d` dependency files alone insufficient for build reuse
3. Target directory structure incomplete without fingerprints
4. No native support for test binary distribution

## Nextest Archive Solution

### What It Provides
- **Complete Test Environment**: All binaries + metadata in single `.tar.zst`
- **Zero Recompilation**: Includes Cargo fingerprints for perfect cache hits
- **Native Partitioning**: Built-in support for parallel test distribution
- **Proven Solution**: Used by major Rust projects (nextest itself, rustc contributors)

### Archive Contents
- ‚úÖ All test binaries (unit, integration, doctests)
- ‚úÖ Cargo metadata and fingerprints
- ‚úÖ Dynamic libraries and dependencies
- ‚úÖ Build script outputs
- ‚úÖ Non-test binaries used by integration tests
- ‚ùå Source code (must be checked out separately)

## Migration Plan

### Step-by-Step Implementation

#### Phase 1: Update Build Job (Minimal Changes)
```yaml
build-artifacts:
  name: Build and Archive Tests
  runs-on: ubuntu-latest
  timeout-minutes: 12
  steps:
    - uses: actions/checkout@v4
    
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        cache-on-failure: true
        shared-key: "nextest-build"
    
    - name: Install nextest
      uses: taiki-e/install-action@nextest
    
    - name: Build all tests and create archive
      run: |
        echo "üèóÔ∏è Building and archiving all tests..."
        # Build release binary separately (not included in test archive)
        cargo build --release --bin kotadb
        
        # Create nextest archive with all test binaries
        cargo nextest archive \
          --archive-file nextest-archive.tar.zst \
          --all-features
        
        echo "üì¶ Archive created: $(du -h nextest-archive.tar.zst)"
    
    - name: Upload test archive
      uses: actions/upload-artifact@v4
      with:
        name: nextest-archive
        path: nextest-archive.tar.zst
        retention-days: 1
        compression-level: 0  # Already compressed
    
    - name: Upload release binary
      uses: actions/upload-artifact@v4
      with:
        name: release-binary
        path: target/release/kotadb
        retention-days: 1
```

#### Phase 2: Update Test Jobs (Simplified)
```yaml
unit-tests:
  name: Unit Tests
  runs-on: ubuntu-latest
  needs: [build-artifacts]
  timeout-minutes: 8
  steps:
    - uses: actions/checkout@v4  # Source needed for test execution
    
    - name: Install nextest
      uses: taiki-e/install-action@nextest
    
    - name: Download test archive
      uses: actions/download-artifact@v4
      with:
        name: nextest-archive
    
    - name: Run unit tests (no compilation)
      run: |
        cargo nextest run \
          --archive-file nextest-archive.tar.zst \
          --lib \
          --no-fail-fast
    
    - name: Run doc tests
      run: cargo test --doc --all-features  # Doc tests need separate run

integration-tests:
  name: Integration Tests (${{ matrix.partition }}/${{ strategy.job-total }})
  runs-on: ubuntu-latest
  needs: [build-artifacts]
  timeout-minutes: 10
  strategy:
    fail-fast: false
    matrix:
      partition: [1, 2, 3, 4]  # Keep 4-way split
  steps:
    - uses: actions/checkout@v4
    
    - name: Install nextest
      uses: taiki-e/install-action@nextest
    
    - name: Download test archive
      uses: actions/download-artifact@v4
      with:
        name: nextest-archive
    
    - name: Run integration tests partition
      run: |
        cargo nextest run \
          --archive-file nextest-archive.tar.zst \
          --test '*' \
          --partition count:${{ matrix.partition }}/4 \
          --no-fail-fast
```

### Alternative: Suite-Based Partitioning

Instead of count-based partitioning, use your existing suite categories:

```yaml
integration-tests:
  strategy:
    matrix:
      suite:
        - core-storage
        - indexing-search
        - api-system
        - performance-stress
  steps:
    - name: Run ${{ matrix.suite }} tests
      run: |
        # Map suite to specific test filters
        case "${{ matrix.suite }}" in
          core-storage)
            FILTER="file_storage|data_integrity|graph_storage"
            ;;
          indexing-search)
            FILTER="index|trigram|query"
            ;;
          api-system)
            FILTER="http|cli|code_analysis"
            ;;
          performance-stress)
            FILTER="performance|concurrent|chaos"
            ;;
        esac
        
        cargo nextest run \
          --archive-file nextest-archive.tar.zst \
          --filter "$FILTER" \
          --no-fail-fast
```

## Performance Projections

### Current Timeline (Failing)
```
Build Artifacts:        10m2s
Quality Checks:         3m    (parallel)
Unit Tests:            14m+   (recompiles)
Integration Tests x4:  14m+ each (recompiles)
E2E Tests:             14m+   (recompiles)
Total:                 ~40-45 minutes
```

### Projected with Nextest Archive
```
Build + Archive:        11m    (+1m for archive creation)
Quality Checks:         3m     (parallel with build)
Unit Tests:            2m     (no compilation)
Integration Tests x4:  3m each (parallel, no compilation)
E2E Tests:             2m     (no compilation)
Total:                 ~14-16 minutes (65% reduction)
```

### Detailed Performance Analysis
- **Archive Creation**: Adds ~1 minute to build time
- **Archive Size**: Expected 100-200MB (compressed)
- **Archive Upload/Download**: ~5-10 seconds each
- **Test Execution**: Pure test runtime, no compilation overhead
- **Parallelization**: True parallel execution without resource contention

## Risk Assessment & Mitigation

### Low-Risk Items
1. **Archive Creation Failure**
   - Mitigation: Retry logic, fallback to current approach
   - Impact: Low - nextest archive is stable

2. **Archive Size Growth**
   - Mitigation: Monitor size, implement cleanup policies
   - Impact: Low - compression is efficient

3. **Nextest Installation**
   - Mitigation: Cache nextest binary, use taiki-e action
   - Impact: Minimal - adds ~10 seconds when not cached

### Medium-Risk Items
1. **Doc Test Compatibility**
   - Issue: Nextest doesn't run doc tests
   - Mitigation: Run `cargo test --doc` separately (small overhead)
   - Impact: Adds 1-2 minutes to one job

2. **Test Discovery Issues**
   - Issue: Some tests might use non-standard patterns
   - Mitigation: Verify all tests are included in archive
   - Impact: One-time verification needed

### Migration-Specific Risks
1. **Incremental Rollout Complexity**
   - Issue: Running both systems in parallel
   - Mitigation: Feature branch with full migration
   - Recommendation: All-at-once migration

## Implementation Timeline

### Day 1: Proof of Concept (2-3 hours)
- [ ] Create feature branch from develop
- [ ] Modify build job to create nextest archive
- [ ] Update one test job (unit tests) to use archive
- [ ] Verify no recompilation occurs
- [ ] Measure performance improvement

### Day 2: Full Migration (3-4 hours)
- [ ] Update all test jobs to use archive
- [ ] Implement partition strategy (count or suite-based)
- [ ] Add doc test execution where needed
- [ ] Update E2E tests
- [ ] Comprehensive testing on feature branch

### Day 3: Validation & Rollout (2-3 hours)
- [ ] Run multiple CI iterations
- [ ] Verify all tests execute correctly
- [ ] Compare coverage reports
- [ ] Performance benchmarking
- [ ] Create PR with migration

## Rollback Plan

If issues arise, rollback is straightforward:

1. **Immediate**: Revert PR to restore original workflow
2. **Temporary**: Keep both workflows, trigger based on branch
3. **Gradual**: Migrate job by job, maintaining hybrid approach

## Key Implementation Details

### Configuration Considerations
```yaml
# Optimal nextest configuration for KotaDB
env:
  NEXTEST_RETRIES: 2  # Retry flaky tests
  NEXTEST_TEST_THREADS: 2  # Match current RUST_TEST_THREADS
  NEXTEST_FAILURE_OUTPUT: immediate  # Show failures immediately
  NEXTEST_SUCCESS_OUTPUT: final  # Summarize successes
```

### Archive Command Options
```bash
# Full archive with all features
cargo nextest archive --all-features --archive-file nextest-archive.tar.zst

# Include additional files if needed
cargo nextest archive --archive-file nextest-archive.tar.zst \
  --extract-to target/ci \
  --workspace-remap .
```

### Partition Strategies
1. **Count-based**: Even distribution across N workers
2. **Hash-based**: Deterministic distribution
3. **Time-based**: Balance by historical execution time

## Expected Outcomes

### Immediate Benefits
- ‚úÖ 65% reduction in CI time (40min ‚Üí 14min)
- ‚úÖ Elimination of redundant compilation
- ‚úÖ Reduced GitHub Actions minutes usage
- ‚úÖ Faster feedback loop for developers

### Long-term Benefits
- ‚úÖ Scalable test infrastructure
- ‚úÖ Foundation for test sharding
- ‚úÖ Easier debugging (each job truly independent)
- ‚úÖ Cost savings on CI infrastructure

## Recommendation

**STRONG RECOMMENDATION TO PROCEED** with nextest archive migration:

1. **Complexity**: LOW - Mostly configuration changes
2. **Risk**: LOW - Well-proven solution with easy rollback
3. **Benefit**: HIGH - 65% CI time reduction
4. **Timeline**: 1-2 days total effort
5. **Maintenance**: LOWER than current approach

The nextest archive approach directly solves your current problem and aligns with Rust CI best practices. The migration is straightforward and the benefits are substantial.

## Next Steps

1. Review this analysis with the team
2. Create feature branch for migration
3. Implement proof of concept with unit tests
4. Measure and validate performance improvements
5. Complete full migration
6. Monitor for one sprint before closing issue

## Additional Resources

- [Nextest Archive Documentation](https://nexte.st/docs/ci-features/archiving/)
- [Example Implementation](https://github.com/nextest-rs/reuse-build-partition-example)
- [Nextest CI Features](https://nexte.st/docs/ci-features/)