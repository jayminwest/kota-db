---
tags:
- file
- kota-db
- ext_rs
---
// E2E Test: Codebase Analysis Journey
// Tests the complete end-to-end workflow from fresh database to analysis results
// This represents the primary user journey for AI assistants using KotaDB

use crate::e2e::{CommandRunner, TestEnvironment};
use anyhow::Result;

/// Test the complete codebase analysis journey
///
/// Journey Steps:
/// 1. Fresh Database Setup - Clean environment initialization
/// 2. Codebase Indexing - Index with symbol extraction
/// 3. Statistics Verification - Validate indexing success
/// 4. Content Search - Test full-text search functionality
/// 5. Symbol Search - Test symbol pattern matching
/// 6. Relationship Analysis - Test dependency tracking
/// 7. Impact Analysis - Test change impact evaluation
#[tokio::test]
#[ignore = "Temporarily disabled - E2E integration test failure tracked in issue #590"]
async fn test_complete_codebase_analysis_journey() -> Result<()> {
    // Step 1: Setup clean test environment
    let env = TestEnvironment::new()?;
    env.setup_test_codebase()?;
    env.ensure_binary_built().await?;

    let runner = CommandRunner::new(&env);

    // Step 2: Index the test codebase with symbols
    println!("🔄 Step 2: Indexing test codebase with symbol extraction...");
    let index_result = runner
        .index_codebase(env.db_path(), env.codebase_path(), true)
        .await?;

    runner.validate_success(&index_result)?;
    runner.validate_performance(&index_result, 60_000)?; // Should complete in <60s

    println!("✅ Indexing completed in {}ms", index_result.duration_ms);

    // Step 3: Skip statistics verification (known issue with stats command)
    println!("⚠️  Step 3: Skipping statistics verification (known stats command issue)");

    // Step 4: Test content search functionality
    println!("🔄 Step 4: Testing content search...");
    let search_result = runner.search_code(env.db_path(), "Storage").await?;

    runner.validate_success(&search_result)?;
    runner.validate_performance(&search_result, 500)?; // Should be <500ms in E2E environment
                                                       // Validate that search returned some results (output contains file paths)
    if search_result.output.trim().is_empty() {
        anyhow::bail!("Search returned no results, expected at least some file matches");
    }

    println!(
        "✅ Content search completed in {}ms",
        search_result.duration_ms
    );

    // Step 5: Test symbol search functionality
    println!("🔄 Step 5: Testing symbol search...");
    let symbol_search_result = runner.search_symbols(env.db_path(), "Storage").await?;

    runner.validate_success(&symbol_search_result)?;
    runner.validate_performance(&symbol_search_result, 500)?; // Should be <500ms in E2E

    println!(
        "✅ Symbol search completed in {}ms",
        symbol_search_result.duration_ms
    );

    // Step 6: Test relationship analysis (find callers)
    println!("🔄 Step 6: Testing relationship analysis...");
    let callers_result = runner.find_callers(env.db_path(), "Storage").await?;

    runner.validate_success(&callers_result)?;
    runner.validate_performance(&callers_result, 1000)?; // Relationship queries can be slower in E2E

    println!(
        "✅ Relationship analysis completed in {}ms",
        callers_result.duration_ms
    );

    // Step 7: Test impact analysis
    println!("🔄 Step 7: Testing impact analysis...");
    let impact_result = runner.analyze_impact(env.db_path(), "Config").await?;

    runner.validate_success(&impact_result)?;
    runner.validate_performance(&impact_result, 1000)?; // Impact analysis can be complex in E2E

    println!(
        "✅ Impact analysis completed in {}ms",
        impact_result.duration_ms
    );

    // Journey completion validation
    println!("✅ Complete codebase analysis journey successful!");
    println!("📊 Performance Summary:");
    println!("  - Indexing: {}ms", index_result.duration_ms);
    println!("  - Content Search: {}ms", search_result.duration_ms);
    println!("  - Symbol Search: {}ms", symbol_search_result.duration_ms);
    println!(
        "  - Relationship Analysis: {}ms",
        callers_result.duration_ms
    );
    println!("  - Impact Analysis: {}ms", impact_result.duration_ms);

    // Validate overall journey performance (excluding stats)
    let total_query_time = search_result.duration_ms
        + symbol_search_result.duration_ms
        + callers_result.duration_ms
        + impact_result.duration_ms;

    // All query operations should complete in reasonable time for E2E
    if total_query_time > 5000 {
        anyhow::bail!(
            "Total query time {}ms exceeds 5000ms target. Performance regression detected.",
            total_query_time
        );
    }

    Ok(())
}

/// Test codebase analysis with large dataset
/// Validates performance under realistic load conditions
#[tokio::test]
#[ignore] // Expensive test - run explicitly with --ignored
async fn test_large_codebase_analysis_performance() -> Result<()> {
    let env = TestEnvironment::new()?;

    // Create a larger, more realistic test codebase
    create_large_test_codebase(env.codebase_path())?;
    env.ensure_binary_built().await?;

    let runner = CommandRunner::new(&env);

    // Index the larger codebase
    println!("🔄 Indexing large test codebase...");
    let index_result = runner
        .index_codebase(env.db_path(), env.codebase_path(), true)
        .await?;

    runner.validate_success(&index_result)?;

    // Test performance on larger dataset
    let search_result = runner.search_code(env.db_path(), "function").await?;

    runner.validate_success(&search_result)?;
    runner.validate_performance(&search_result, 10)?; // Should still be <10ms

    println!("✅ Large dataset search: {}ms", search_result.duration_ms);

    Ok(())
}

/// Test error recovery scenarios
/// Validates graceful handling of error conditions
#[tokio::test]
async fn test_error_recovery_scenarios() -> Result<()> {
    let env = TestEnvironment::new()?;
    env.ensure_binary_built().await?;

    let runner = CommandRunner::new(&env);

    // Test search on empty database (should handle gracefully)
    println!("🔄 Testing search on empty database...");
    let empty_search = runner.search_code(env.db_path(), "nonexistent").await?;

    runner.validate_success(&empty_search)?;
    runner.validate_performance(&empty_search, 500)?; // Should be reasonable in E2E

    // Test stats on empty database
    let empty_stats = runner.stats(env.db_path(), false).await?;
    runner.validate_success(&empty_stats)?;

    println!("✅ Error recovery scenarios passed");

    Ok(())
}

/// Creates a larger, more realistic test codebase for performance testing
fn create_large_test_codebase(base_dir: &std::path::Path) -> Result<()> {
    use std::fs;

    let src_dir = base_dir.join("src");
    fs::create_dir_all(&src_dir)?;

    // Create multiple modules with realistic content
    for i in 0..10 {
        let module_content = format!(
            r#"//! Module {} for testing
            
use std::collections::HashMap;
use serde::{{Serialize, Deserialize}};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataProcessor{} {{
    cache: HashMap<String, String>,
    config: ProcessorConfig,
}}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessorConfig {{
    max_items: usize,
    timeout_ms: u64,
    enable_caching: bool,
}}

impl DataProcessor{} {{
    pub fn new(config: ProcessorConfig) -> Self {{
        Self {{
            cache: HashMap::new(),
            config,
        }}
    }}
    
    pub async fn process_item(&mut self, key: &str, value: &str) -> Result<String, String> {{
        if self.config.enable_caching {{
            if let Some(cached) = self.cache.get(key) {{
                return Ok(cached.clone());
            }}
        }}
        
        let result = format!("processed_{}_{{value}}", key);
        
        if self.config.enable_caching {{
            self.cache.insert(key.to_string(), result.clone());
        }}
        
        Ok(result)
    }}
    
    pub fn clear_cache(&mut self) {{
        self.cache.clear();
    }}
    
    pub fn get_stats(&self) -> ProcessorStats {{
        ProcessorStats {{
            cache_size: self.cache.len(),
            cache_enabled: self.config.enable_caching,
        }}
    }}
}}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessorStats {{
    pub cache_size: usize,
    pub cache_enabled: bool,
}}

pub fn create_default_config() -> ProcessorConfig {{
    ProcessorConfig {{
        max_items: 1000,
        timeout_ms: 5000,
        enable_caching: true,
    }}
}}
"#,
            i, i, i, i
        );

        fs::write(src_dir.join(format!("processor_{}.rs", i)), module_content)?;
    }

    // Create lib.rs that references all modules
    let lib_content = (0..10)
        .map(|i| format!("pub mod processor_{};", i))
        .collect::<Vec<_>>()
        .join("\n");

    fs::write(src_dir.join("lib.rs"), lib_content)?;

    // Create Cargo.toml
    fs::write(
        base_dir.join("Cargo.toml"),
        r#"[package]
name = "large-test-codebase"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
"#,
    )?;

    Ok(())
}
